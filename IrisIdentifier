import matplotlib.pyplot as plt
import numpy as np
import random

data = np.loadtxt(fname="irisData.txt")
print(len(data))
x1 = []
x2 = []
y1 = []
y2 = []
for d in data:
    if d[2] == 1:
        x1.append(d[0])
        y1.append(d[1])
        d[2] = 0
    else:
        x2.append(d[0])
        y2.append(d[1])
        d[2] = 1
        
plt.scatter(x1,y1,color="red" ) 
plt.scatter(x2,y2,color = "blue")
#plt.show()
#print(data)




class Perceptron():
    NumEpoch = 0
    def __init__(self, w, threshold,variation):
     self.w = w
     self.threshold = threshold
     self.variation = variation

    def TreinarEpoca(self,Data):
        print("Epoch - " + str(self.NumEpoch))
        ContCorrec = 0
        for v in Data:
          if  self.Calcular(v) == 1:
              ContCorrec += 1
        self.NumEpoch +=1
        print("Valores Finais na Epoch  -- " + str(self.w))
        print("---------------------------------")
        return ContCorrec

    def Calcular(self,vet):
        print(vet)
        func = self.w[0] + vet[0] * self.w[1] + vet [1] * self.w[2] #u         
        print("  \"" + str(vet[0]) +"\" * \""  + str(self.w[1]) + "  \" " + str(vet[1]) +"\" * " + str(self.w[2]) + " + Bias " + str(self.w[0]) + " = " + str(func) ) 
        if func >= self.threshold:
                func = 2
        else:
                func = 1
        #func = 1/( 1 + np.exp(func))
        if (func-1 == vet[2]) :
            return 0 #se funcionar
        else:
            if func>=self.threshold:
                func = 2
            else:
                func = 1
            self.Corrigir(vet,  (vet[2]+1) - func )    
            return 1 #se nao funcioanr

    #Direction deve ser 1 para corrigir positivamento e -1 para corrigir negativamente
    def  Corrigir(self,vet,erro):#variacao ajuste 
        self.w[0] += self.variation * erro 
        print("Variacao Bias - " + str(self.w[0]))
       #if(vet[0] > 0 ):
        self.w[1] += self.variation * erro* vet[0]
        print("Variacao W1 - " + str(self.w[1])) 
       # if(vet[1] > 0):
        self.w[2] += self.variation * erro* vet[1]
        print("Variacao W2 - " + str(self.w[2])) 


p = Perceptron([random.uniform(-1,1),random.uniform(-1,1),random.uniform(-1,1)],0,0.1)
#-3.63 5.61 2.10
#p = Perceptron([2.10,-3.63,5.61],0,0.1)
#p = Perceptron([0.7,0.7,-1.3],0,0.1)
epoch = 100
resposta = 1
erro = 100
while (resposta != 0) and epoch>0 and erro > 5:
    resposta = p.TreinarEpoca(data)
    epoch-=1
    erro = (resposta/len(data))*100
    print("---------------------------------------------------")
    print("Erros/Total" + str(resposta) + "/" +str(len(data)) + " = " + str(erro)+"%")
    print("---------------------------------------------------")
    continue

xp1 = ((-1)*p.w[0]/p.w[1] )
xp2 = ((-1)*p.w[0]/p.w[2] )
pontos = [[0,xp1],[xp2,0]]
z = np.polyfit(pontos[0], pontos[1], 1) #pega uma equacao para a reta
p = np.poly1d(z) #a transforma em polinomial
print(p)
x = np.arange(10)
y = p(x)
plt.plot(x,y, '--',color="black")
print(plt.axis())
plt.show()
